#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+OPTIONS: toc:nil

#+HUGO_BASE_DIR: /home/shane/var/smulliga/source/git/semiosis/semiosis-hugo
#+HUGO_SECTION: ./posts

#+TITLE: Imaginary programming with GPT-3
#+DATE: <2021-04-08>
#+AUTHOR: Shane Mulligan
#+KEYWORDS: gpt openai imaginary-programming

+ Code :: https://github.com/semiosis/pen.el

+ Prompts :: https://github.com/semiosis/prompts/

+ Disclaimer :: Please contribute as this is an open source project! It's very hard to find free prompts online currently and that's because everyone is out for themselves. Please support open source. Thank you.

+ Glossary :: http://github.com/semiosis/glossaries-gh/blob/master/imaginary-programming.txt

** Summary
This is a demonstration of an imaginary
programming environment. There may be nothing
else like it in the world today.

The world needs to get ready for the next
generations of Large LMs, such as =GPT-4=.

Indeed, they will be able to dream up the
entire experience of a textual user interface
by inferring how it changes based on keyboard
input. That is because a =tty= is simple text
stream.

A current generation GPT trained on =tty=
recordings would most certainly probably be
able to do this already, but with =GPT-4= and
future LMs comes convenience in the form of
prompt tuning.

An imaginary programming environment is [[https://github.com/semiosis/pen.el/blob/master/docs/README.org][one of the supported features]] of =pen.el=.

*** What does it mean to be imaginary?
Several of the components of a normal
programming environment are replaced by
functions that infer rather than evaluate.

These components are replaced by GPT-3 prompts.
- linter,
- indenter/reformatter,
- code completion,
- interpreter

Imaginary seems to be a good word because:
- GPT-3 is imagining the environment, the code and the output.
- the languages are kinda like imaginary numbers. They are all understood within the same language model, kinda like a coordinate space.
- It lets you be very imaginative!

*** The implications
- There are no interpreters or compilers being used but you can still generate code using words and evaluate code by inference.
- All requests take the same amount of time to run.
- All languages have equally facilitated environments.
- You may program in any language.
- It runs broken code.
- One day you may design new languages within the latent space of GPT-3, without doing any programming.
- You may have an interpreter for languages with no interpreter, such as C++.
- You may have code completion for scripting languages without a completion engine.
- You may use it for languages which are dead and an interpreter is not available.
- It's great for thought experiments.

*** Literate programming
According to Wikipedia, _literate programming_
is a programming paradigm introduced by Donald
Knuth in which a computer program is given an
explanation of its logic in a NL, such as
English, interspersed with snippets of macros
and traditional source code, from which
compilable source code can be generated.

The approach is used in scientific computing
and in data science routinely for reproducible
research and open access purposes.

Literate programming tools are used by
millions of programmers today.

+ Literate programming :: https://en.wikipedia.org/wiki/Literate_programming

*** Imaginary programming
Imaginary programming (IP) seems to be
orthogonal to literate programming. Imaginary
programming is a programming paradigm in which
a computer program's behaviour exists in
relativity to LMs. To make an analogy, imaginary programming is a
type of programming, where much like pure-
functional, the code who's behaviour depends
on the output of a LM, either pending or
precomputed, stands apart from the part that
has no such association.

What is deemed /imaginary/ is code that uses
or is waiting on output from a LM and its
behaviour is so altered by it. What is deemed
/ordinary/ is code which is not /imaginary/.

A distinction is made between grounded and
non-grounded imaginary programming. /Non-grounded imaginary programming/ may also be
called /pure imaginary programming/.

If a function has a LM as a parameter
affecting its behaviour and besides from that
has no other imaginary inputs then it is
considered /grounded/. If a function has a LM as a parameter
affecting its behaviour and contains other
imaginary inputs then it is considered
/tethered/'.

If an imaginary function relies on the output
of functions that have in the past used a LM
as a parameter, but does not contain a
reference to specific LM used then it is
considered /non-grounded/ or /pure imaginary/.

A function can be both tethered and pure
imaginary.

Pure imaginary code is still code in a similar
way to how pure functional code is considered
code and may be used to create useful
datastructures and algorithms.

Ordinary programming is programming with
functions that do not have an imaginary
dimension (they do not take a LM as a
parameter and the result of ordinary code is
not polluted by a LM).

=Holographic programming= is like imaginary
programming but where the LMs are trained on
software. Holographic code, therefore, may
employ associations made between elements of
the original code, how that code is used and
how it is described, to build applications.
Holographic programming lets you use the
latent space of a LM as a kind of hyperspace
to enable things like:
- bridge the usage of an application with
  the application's code
- imaginary reflection
- inference in place of computation

*** Current progress
Some of the plumbing, including the
interpreter and the autocompletion system are
in an =MVP= stage.

** Latest GPT-3 Demonstration (Aug 25, 2021)
- https://mullikine.github.io/posts/an-emacs-imaginary-interpreter-with-history-completion-and-evaluation/

#+BEGIN_EXPORT html
<!-- Play on asciinema.com -->
<!-- <a title="asciinema recording" href="https://asciinema.org/a/6EKIiUqvOSKetO6Fz439xZitE" target="_blank"><img alt="asciinema recording" src="https://asciinema.org/a/6EKIiUqvOSKetO6Fz439xZitE.svg" /></a> -->
<!-- Play on the blog -->
<script src="https://asciinema.org/a/6EKIiUqvOSKetO6Fz439xZitE.js" id="asciicast-6EKIiUqvOSKetO6Fz439xZitE" async></script>
#+END_EXPORT

** Original Demonstration (April 2, 2021)
#+BEGIN_EXPORT html
<!-- Play on asciinema.com -->
<!-- <a title="asciinema recording" href="https://asciinema.org/a/G8HPLtlCWTQIzGssLrM3ZvxhT" target="_blank"><img alt="asciinema recording" src="https://asciinema.org/a/G8HPLtlCWTQIzGssLrM3ZvxhT.svg" /></a> -->
<!-- Play on the blog -->
<script src="https://asciinema.org/a/G8HPLtlCWTQIzGssLrM3ZvxhT.js" id="asciicast-G8HPLtlCWTQIzGssLrM3ZvxhT" async></script>
#+END_EXPORT

** Prompts and demonstrations
*** Linter (Update: Sep 1, 2021)
- https://mullikine.github.io/posts/an-imaginary-linter-with-codex/

*** Reformatter and Syntax corrector (Update: Sep 1, 2021)
- https://mullikine.github.io/posts/a-syntax-corrector-with-codex/

** Prompts
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-ammonite-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-emacs-lisp-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-fish-shell-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-haskell-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-javascript-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-julia-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-lua-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-nushell-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-perl-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-powershell-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-prolog-db-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-prolog-db-swipl-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-prolog-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-prolog-pseudocode-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-python-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-ruby-interpreter-2.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-scala-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-scheme-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-a-smalltalk-interpreter-1.prompt
- http://github.com/semiosis/prompts/blob/master/prompts/imagine-an-awk-linter-1.prompt

*** kickstarter
This prompt initiates the imaginary interpreter / REPL.

#+BEGIN_SRC yaml -n :async :results verbatim code
  include: Generic Interpreter/3
  task: Imagine a <language> interpreter
  language: python
  subprompts:
  - kickstarter: |+
      Python 3.8.5 (default, Jan 27 2021, 15:41:15)
      Type 'copyright', 'credits' or 'license' for more information
      IPython 7.21.0 -- An enhanced Interactive Python. Type '?' for help.
      
      In [1]: 
  prompt: |+
      <history><expression>
      <:pp>Out
  user-prompt: "^In \\[[0-9]*\\]: "
  # Unfortunately, we can't generate the next In
  # prompt because we need to match on it with stop-sequences.
  # So the user prompt must be reconstructed manually.
  stop-sequences:
  - "In ["
  # Create a user prompt with the number incremented.
  # This is like postprocessor but happens even later.
  # It is used in special circumstances when the prompt history is also required.
  postpostprocessor: pen-str python-gen-next-user-prompt
  vars:
  - history
  - expression
  var-defaults:
  - kickstarter
  examples:
  - "In [1]: "
  - "5 + 5"
#+END_SRC

*** conjugator
This prompt is part of the _interpreter conjugator_, and enables the _imaginary interpreter_ to continue the "conversation"
more optimally than the _kickstarter_ prompt.

Conjugation is comprised of melding and a sliding window.

- http://github.com/semiosis/prompts/blob/master/prompts/meld-two-passages-2.prompt
- http://github.com/semiosis/pen.el/blob/master/scripts/pen-sliding-window