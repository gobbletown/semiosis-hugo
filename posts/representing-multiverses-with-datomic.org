#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+OPTIONS: toc:nil

#+HUGO_BASE_DIR: /home/shane/var/smulliga/source/git/semiosis/semiosis-hugo
#+HUGO_SECTION: ./posts

#+TITLE: Representing multiverses with Datomic
#+DATE: <2021-06-26>
#+AUTHOR: Shane Mulligan
#+KEYWORDS: gpt clojure

** Related articles
- [[https://generative.ink/posts/language-models-are-multiverse-generators/][Language models are multiverse generators =::=  Moire]]
  - =|:ϝ∷¦ϝ='s blog post on exploring language models.
- [[https://www.youtube.com/watch?v=9TYfcyvSpEQ][Datomic with Rich Hickey - YouTube]]
- [[https://www.youtube.com/watch?v=7Fi-UvrRpyI][Writing Datomic in Clojure - Rich Hickey - YouTube]]
- [[https://gist.github.com/prakhar1989/1b0a2c9849b2e1e912fb][richhickey.md GitHub]]
  - Rich Hickey on becoming a better developer

** Summary
I investigate Datomic as an appropriate
storage for storing LM generations.

Something which caught my attention which Rich
Hickey mentioned was the need for immutability
and to *not* throw away data, in order to make progress.

In the markdown file linked to above and in
his videos about Datomic Rich Hickey tells us
that tells us that mastery comes from always
working slightly beyond your comfort/ability
zone, pushing it ever forward. He also
designed Datomic to efficiently accrete
and distribute knowledge, whilst remaining
queryable. It allows you to both offload logic
to the database and run logic locally which
would've been conducted on the database.

=|:ϝ∷¦ϝ= also mentioned this when we talked
about keeping our notes around and one day
fine-tuning LMs on them.

Since we are now using LM's to facilitate our
creativity, we need a rock solid and
distributed foundation for retaining memories.
Datomic is a great candidate for such a
database.

- It's a time-travelling database
  - https://stackoverflow.com/questions/49309263/how-to-achieve-time-travel-with-clojure/49310124
- An entire database is considered a value.
- Transactions are broken down into functions.
- A local copy is kept inside the application.
- Datomic has a lisp domain specific logic-oriented language embedded for doing querying.
  - [[https://mullikine.github.io/posts/generate-graphviz-and-prolog-from-org-brain/][Generate graphviz and prolog from org-brain // Bodacious Blog]]
    - Datomic is a semantic subset of prolog.
    - It's a lisp, so is naturally multidimensional in structure.

** [[https://www.youtube.com/watch?v=9TYfcyvSpEQ][Datomic with Rich Hickey - YouTube]]
 - Datomic can harness storage from many different storage and database services
   - Even relational databases
 - Has pluggable comparators
   - Two sorts that are always maintained
     - Primary by entity
     - Primary by attribute
 - Has both the characteristics of a document store and a column store
 - assert and retract are insufficient
   - So we have tx-fn (transaction functions)
 - stable basis
   - same query (including time), same result
 - transactions well defined
   - A transaction is a function to a database
   - functional accretion
 - Embedded Datalog
   - [[https://youtu.be/9TYfcyvSpEQ][Datomic with Rich Hickey - YouTube]]
   - Subset of Prolog.
   - guaranteed termination.
   - Set oriented.
     Has set orientation, unlike prolog which
     is tuple at a time.
   - A datalog program contains
     - db(s) + rules + queries
       - one or more databases,
       - a set of rules which you can map to views
       - a set of queries
   - Completely data-driven interface to datalog
   - has the power of relational algebra
   - It's embedded in clojure
     - syntactically subset of Clojure
     - semantically subset of prolog

*** Example datalog code
 - [[https://youtu.be/9TYfcyvSpEQ][Datomic with Rich Hickey - YouTube]]

 Can read this as a map where each key maps to a list.

 #+BEGIN_SRC clojure -n :i clj :async :results verbatim code
   {:find [?customer ?product]
    :where [[?customer :shipAddress ?addr]
            [?addr :zip ?zip]
            [?product :product/weight ?weight]

            [?product :product/price ?price]
            [(Shipping/estimate ?zip ?weight) ?shipCost]
            [(<= ?price ?shipCost)]]}
 #+END_SRC

 No joins -- all joins are implicit.

 Unification unifies all the values of customer
 to be the same customer as the product ~~...

** [[https://www.youtube.com/watch?v=7Fi-UvrRpyI][Writing Datomic in Clojure - Rich Hickey - YouTube]]
 Database is distributed.

 Brings power from database (where
 traditionally it would be found), to the
 application logic.

 - The application gets its own brain (datomic database copy)
   - The app becomes a peer
   - The db is effectively local

*** datalog
 - The big advantage over =core.logic= or =prolog=
   - The semantics of those are tuple at a time
   - The semantics of datalog is set at a time
     - This means that underneath the hood, entire sets are being merge-joined

**** Peer implementation
[[https://youtu.be/7Fi-UvrRpyI][Writing Datomic in Clojure - Rich Hickey - YouTube]]

**** Consistency and Scale

**** Testing
 - Functional tests
 - Simulation-based testing
   - I like.

** Querying Datomic
#+BEGIN_EXPORT html
<!-- Play on asciinema.com -->
<!-- <a title="asciinema recording" href="https://asciinema.org/a/4EMtFoULbap3OtMKg9HqFojf5" target="_blank"><img alt="asciinema recording" src="https://asciinema.org/a/4EMtFoULbap3OtMKg9HqFojf5.svg" /></a> -->
<!-- Play on the blog -->
<script src="https://asciinema.org/a/4EMtFoULbap3OtMKg9HqFojf5.js" id="asciicast-4EMtFoULbap3OtMKg9HqFojf5" async></script>
#+END_EXPORT